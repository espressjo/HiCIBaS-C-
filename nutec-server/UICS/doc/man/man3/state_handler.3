.TH "state_handler" 3 "Wed Oct 20 2021" "Version 1.0" "UICS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
state_handler
.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstate_handler\fP (\fBinstHandle\fP *handle)"
.br
.RI "State handler constructor Will create the port to communicate with the different states and the message handler\&. Also upload the state transition file\&. Initialize all the states and add the callback function\&. By default, the first state to be executed if the default state INIT\&. "
.ti -1c
.RI "void \fBrun\fP ()"
.br
.RI "Main method Will start the incoming message thread\&. This is an infinite loop that will run the different state\&. If another state needs to be added, one must difine a new case for this state here\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBuics_state\fP * \fBs_config\fP"
.br
.ti -1c
.RI "\fBuics_state\fP * \fBs_idle\fP"
.br
.ti -1c
.RI "\fBuics_state\fP * \fBs_init\fP"
.br
.ti -1c
.RI "\fBuics_state\fP * \fBs_acq\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 18 of file state_handler\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "state_handler::state_handler (\fBinstHandle\fP * handle)"

.PP
State handler constructor Will create the port to communicate with the different states and the message handler\&. Also upload the state transition file\&. Initialize all the states and add the callback function\&. By default, the first state to be executed if the default state INIT\&. 
.PP
Definition at line 38 of file state_handler\&.cpp\&.
.PP
.nf
47 {
48 
49     commfd = create_socket(PORT4MSG);
50     sockfd = create_socket(PORT4STATE);//pour les states
51     //parsing the state config file\&.
52     parseState(join(CONFPATH,"state\&.conf"));
53 
54     msg = "";
55     myHandle = handle;
56 
57 
58     myHandle->nextState = INIT;
59     myHandle->state = INIT;
60 
61     //init all states
62     s_config= new uics_state(handle);
63 
64     s_init= new uics_state(handle);
65     s_acq = new uics_state(handle);
66     s_idle= new uics_state(handle);
67     //add more state here
68 
69     //add a few callback\&.\&.
70 
71 }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void state_handler::run ()"

.PP
Main method Will start the incoming message thread\&. This is an infinite loop that will run the different state\&. If another state needs to be added, one must difine a new case for this state here\&. 
.PP
Definition at line 73 of file state_handler\&.cpp\&.
.PP
.nf
81 {
82     std::thread t_handler(&state_handler::handler,this);
83     //start the state incoming msg handler\&.
84     t_handler\&.detach();
85     sleep(1);
86     while (1) {
87         switch (myHandle->nextState) {
88             case ACQ:{
89                 //always set the current state
90                 std::cout<<"Starting ACQ"<<std::endl;
91                 log_stateH("Starting ACQ");
92                 myHandle->state = ACQ;
93                 s_acq->run(sockfd);
94                 std::cout<<"Exit ACQ"<<std::endl;
95                 log_stateH("Exit ACQ");
96                 break;
97             }
98             case IDLE:{
99                 //always set the current state
100                 std::cout<<"Starting IDLE"<<std::endl;
101                 log_stateH("Starting IDLE");
102                 myHandle->state = IDLE;
103                 s_idle->run(sockfd);
104                 std::cout<<"Exit IDLE"<<std::endl;
105                 log_stateH("Exit IDLE");
106                 break;
107             }
108             case INIT:{
109                 //always set the current state
110                 std::cout<<"Starting INIT"<<std::endl;
111                 log_stateH("Starting INIT");
112                 myHandle->state = INIT;
113                 s_init->run(sockfd);
114                 std::cout<<"Exit INIT"<<std::endl;
115                 log_stateH("Exit INIT");
116                 break;
117             }
118             case CONFIG:{
119                 //always set the current state
120                 std::cout<<"Starting CONFIG"<<std::endl;
121                 log_stateH("Starting CONFIG");
122                 myHandle->state = CONFIG;
123                 s_config->run(sockfd);
124                 std::cout<<"Exit CONFIG"<<std::endl;
125                 log_stateH("Exit CONFIG");
126                 break;
127             }
128 
129             default:{
130                 sleep(1);
131                 std::cout<<"big problem"<<std::endl;
132                 log_stateH("major issue");
133                 break;
134             }
135 
136         }//switch
137     }//while
138 }
.fi


.SH "Author"
.PP 
Generated automatically by Doxygen for UICS from the source code\&.
